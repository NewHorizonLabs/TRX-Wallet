// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Tron.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/Any.pbobjc.h>
#else
 #import "google/protobuf/Any.pbobjc.h"
#endif

 #import "Tron.pbobjc.h"
 #import "Discover.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - TronRoot

@implementation TronRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - TronRoot_FileDescriptor

static GPBFileDescriptor *TronRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum AccountType

GPBEnumDescriptor *AccountType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000AssetIssue\000Contract\000";
    static const int32_t values[] = {
        AccountType_Normal,
        AccountType_AssetIssue,
        AccountType_Contract,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\n\000\002\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccountType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccountType_Normal:
    case AccountType_AssetIssue:
    case AccountType_Contract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ReasonCode

GPBEnumDescriptor *ReasonCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Requested\000BadProtocol\000TooManyPeers\000Dupli"
        "catePeer\000IncompatibleProtocol\000NullIdenti"
        "ty\000PeerQuiting\000UnexpectedIdentity\000LocalI"
        "dentity\000PingTimeout\000UserReason\000Reset\000Syn"
        "cFail\000FetchFail\000BadTx\000BadBlock\000Forked\000Un"
        "linkable\000IncompatibleVersion\000Incompatibl"
        "eChain\000TimeOut\000ConnectFail\000TooManyPeersW"
        "ithSameIp\000Unknown\000";
    static const int32_t values[] = {
        ReasonCode_Requested,
        ReasonCode_BadProtocol,
        ReasonCode_TooManyPeers,
        ReasonCode_DuplicatePeer,
        ReasonCode_IncompatibleProtocol,
        ReasonCode_NullIdentity,
        ReasonCode_PeerQuiting,
        ReasonCode_UnexpectedIdentity,
        ReasonCode_LocalIdentity,
        ReasonCode_PingTimeout,
        ReasonCode_UserReason,
        ReasonCode_Reset,
        ReasonCode_SyncFail,
        ReasonCode_FetchFail,
        ReasonCode_BadTx,
        ReasonCode_BadBlock,
        ReasonCode_Forked,
        ReasonCode_Unlinkable,
        ReasonCode_IncompatibleVersion,
        ReasonCode_IncompatibleChain,
        ReasonCode_TimeOut,
        ReasonCode_ConnectFail,
        ReasonCode_TooManyPeersWithSameIp,
        ReasonCode_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReasonCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReasonCode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReasonCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReasonCode_Requested:
    case ReasonCode_BadProtocol:
    case ReasonCode_TooManyPeers:
    case ReasonCode_DuplicatePeer:
    case ReasonCode_IncompatibleProtocol:
    case ReasonCode_NullIdentity:
    case ReasonCode_PeerQuiting:
    case ReasonCode_UnexpectedIdentity:
    case ReasonCode_LocalIdentity:
    case ReasonCode_PingTimeout:
    case ReasonCode_UserReason:
    case ReasonCode_Reset:
    case ReasonCode_SyncFail:
    case ReasonCode_FetchFail:
    case ReasonCode_BadTx:
    case ReasonCode_BadBlock:
    case ReasonCode_Forked:
    case ReasonCode_Unlinkable:
    case ReasonCode_IncompatibleVersion:
    case ReasonCode_IncompatibleChain:
    case ReasonCode_TimeOut:
    case ReasonCode_ConnectFail:
    case ReasonCode_TooManyPeersWithSameIp:
    case ReasonCode_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AccountId

@implementation AccountId

@dynamic name;
@dynamic address;

typedef struct AccountId__storage_ {
  uint32_t _has_storage_[1];
  NSData *name;
  NSData *address;
} AccountId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AccountId_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountId__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AccountId_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountId__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Vote

@implementation Vote

@dynamic voteAddress;
@dynamic voteCount;

typedef struct Vote__storage_ {
  uint32_t _has_storage_[1];
  NSData *voteAddress;
  int64_t voteCount;
} Vote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voteAddress",
        .dataTypeSpecific.className = NULL,
        .number = Vote_FieldNumber_VoteAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Vote__storage_, voteAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = Vote_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Vote__storage_, voteCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Vote class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vote__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Proposal

@implementation Proposal

@dynamic proposalId;
@dynamic proposerAddress;
@dynamic parameters, parameters_Count;
@dynamic expirationTime;
@dynamic createTime;
@dynamic approvalsArray, approvalsArray_Count;
@dynamic state;

typedef struct Proposal__storage_ {
  uint32_t _has_storage_[1];
  Proposal_State state;
  NSData *proposerAddress;
  GPBInt64Int64Dictionary *parameters;
  NSMutableArray *approvalsArray;
  int64_t proposalId;
  int64_t expirationTime;
  int64_t createTime;
} Proposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "proposalId",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ProposalId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Proposal__storage_, proposalId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ProposerAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Proposal__storage_, proposerAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parameters",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_Parameters,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Proposal__storage_, parameters),
        .flags = GPBFieldMapKeyInt64,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expirationTime",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ExpirationTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Proposal__storage_, expirationTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Proposal__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "approvalsArray",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ApprovalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Proposal__storage_, approvalsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = Proposal_State_EnumDescriptor,
        .number = Proposal_FieldNumber_State,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Proposal__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Proposal class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Proposal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Proposal_State_RawValue(Proposal *message) {
  GPBDescriptor *descriptor = [Proposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetProposal_State_RawValue(Proposal *message, int32_t value) {
  GPBDescriptor *descriptor = [Proposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Proposal_State

GPBEnumDescriptor *Proposal_State_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Pending\000Disapproved\000Approved\000Canceled\000";
    static const int32_t values[] = {
        Proposal_State_Pending,
        Proposal_State_Disapproved,
        Proposal_State_Approved,
        Proposal_State_Canceled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Proposal_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Proposal_State_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Proposal_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case Proposal_State_Pending:
    case Proposal_State_Disapproved:
    case Proposal_State_Approved:
    case Proposal_State_Canceled:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Exchange

@implementation Exchange

@dynamic exchangeId;
@dynamic creatorAddress;
@dynamic createTime;
@dynamic firstTokenId;
@dynamic firstTokenBalance;
@dynamic secondTokenId;
@dynamic secondTokenBalance;

typedef struct Exchange__storage_ {
  uint32_t _has_storage_[1];
  NSData *creatorAddress;
  NSData *firstTokenId;
  NSData *secondTokenId;
  int64_t exchangeId;
  int64_t createTime;
  int64_t firstTokenBalance;
  int64_t secondTokenBalance;
} Exchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_ExchangeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Exchange__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creatorAddress",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_CreatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Exchange__storage_, creatorAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Exchange__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "firstTokenId",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_FirstTokenId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Exchange__storage_, firstTokenId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "firstTokenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_FirstTokenBalance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Exchange__storage_, firstTokenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "secondTokenId",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_SecondTokenId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Exchange__storage_, secondTokenId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "secondTokenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_SecondTokenBalance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Exchange__storage_, secondTokenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Exchange class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Exchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainParameters

@implementation ChainParameters

@dynamic chainParameterArray, chainParameterArray_Count;

typedef struct ChainParameters__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *chainParameterArray;
} ChainParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chainParameterArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainParameters_ChainParameter),
        .number = ChainParameters_FieldNumber_ChainParameterArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainParameters__storage_, chainParameterArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainParameters class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainParameters__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000chainParameter\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainParameters_ChainParameter

@implementation ChainParameters_ChainParameter

@dynamic key;
@dynamic value;

typedef struct ChainParameters_ChainParameter__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  int64_t value;
} ChainParameters_ChainParameter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ChainParameters_ChainParameter_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainParameters_ChainParameter__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ChainParameters_ChainParameter_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainParameters_ChainParameter__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainParameters_ChainParameter class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainParameters_ChainParameter__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChainParameters)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account

@implementation TronAccount

@dynamic accountName;
@dynamic type;
@dynamic address;
@dynamic balance;
@dynamic votesArray, votesArray_Count;
@dynamic asset, asset_Count;
@dynamic frozenArray, frozenArray_Count;
@dynamic netUsage;
@dynamic createTime;
@dynamic latestOprationTime;
@dynamic allowance;
@dynamic latestWithdrawTime;
@dynamic code;
@dynamic isWitness;
@dynamic isCommittee;
@dynamic frozenSupplyArray, frozenSupplyArray_Count;
@dynamic assetIssuedName;
@dynamic latestAssetOperationTime, latestAssetOperationTime_Count;
@dynamic freeNetUsage;
@dynamic freeAssetNetUsage, freeAssetNetUsage_Count;
@dynamic latestConsumeTime;
@dynamic latestConsumeFreeTime;
@dynamic accountId;
@dynamic hasAccountResource, accountResource;
@dynamic codeHash;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  AccountType type;
  NSData *accountName;
  NSData *address;
  NSMutableArray *votesArray;
  GPBStringInt64Dictionary *asset;
  NSMutableArray *frozenArray;
  NSData *code;
  NSMutableArray *frozenSupplyArray;
  NSData *assetIssuedName;
  GPBStringInt64Dictionary *latestAssetOperationTime;
  GPBStringInt64Dictionary *freeAssetNetUsage;
  NSData *accountId;
  Account_AccountResource *accountResource;
  NSData *codeHash;
  int64_t balance;
  int64_t netUsage;
  int64_t createTime;
  int64_t latestOprationTime;
  int64_t allowance;
  int64_t latestWithdrawTime;
  int64_t freeNetUsage;
  int64_t latestConsumeTime;
  int64_t latestConsumeFreeTime;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AccountType_EnumDescriptor,
        .number = Account_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Balance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "votesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Account_FieldNumber_VotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, votesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asset",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Asset,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, asset),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_FieldNumber_FrozenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, frozenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "netUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_NetUsage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account__storage_, netUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_CreateTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Account__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestOprationTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestOprationTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Account__storage_, latestOprationTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "allowance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Allowance,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Account__storage_, allowance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestWithdrawTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestWithdrawTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Account__storage_, latestWithdrawTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Code,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Account__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "isWitness",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_IsWitness,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isCommittee",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_IsCommittee,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "frozenSupplyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_FieldNumber_FrozenSupplyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, frozenSupplyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetIssuedName",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AssetIssuedName,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Account__storage_, assetIssuedName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "latestAssetOperationTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestAssetOperationTime,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, latestAssetOperationTime),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeNetUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeNetUsage,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Account__storage_, freeNetUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeAssetNetUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeAssetNetUsage,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, freeAssetNetUsage),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestConsumeTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestConsumeTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Account__storage_, latestConsumeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestConsumeFreeTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestConsumeFreeTime,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Account__storage_, latestConsumeFreeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountId,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Account__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accountResource",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_AccountResource),
        .number = Account_FieldNumber_AccountResource,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Account__storage_, accountResource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "codeHash",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_CodeHash,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Account__storage_, codeHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TronAccount class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\036\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Account_Type_RawValue(TronAccount *message) {
  GPBDescriptor *descriptor = [TronAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetAccount_Type_RawValue(TronAccount *message, int32_t value) {
  GPBDescriptor *descriptor = [TronAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Account_Frozen

@implementation Account_Frozen

@dynamic frozenBalance;
@dynamic expireTime;

typedef struct Account_Frozen__storage_ {
  uint32_t _has_storage_[1];
  int64_t frozenBalance;
  int64_t expireTime;
} Account_Frozen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "frozenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Account_Frozen_FieldNumber_FrozenBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account_Frozen__storage_, frozenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_Frozen_FieldNumber_ExpireTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account_Frozen__storage_, expireTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account_Frozen class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_Frozen__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TronAccount)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account_AccountResource

@implementation Account_AccountResource

@dynamic energyUsage;
@dynamic hasFrozenBalanceForEnergy, frozenBalanceForEnergy;
@dynamic latestConsumeTimeForEnergy;
@dynamic storageLimit;
@dynamic storageUsage;
@dynamic latestExchangeStorageTime;

typedef struct Account_AccountResource__storage_ {
  uint32_t _has_storage_[1];
  Account_Frozen *frozenBalanceForEnergy;
  int64_t energyUsage;
  int64_t latestConsumeTimeForEnergy;
  int64_t storageLimit;
  int64_t storageUsage;
  int64_t latestExchangeStorageTime;
} Account_AccountResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "energyUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_EnergyUsage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, energyUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenBalanceForEnergy",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_AccountResource_FieldNumber_FrozenBalanceForEnergy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, frozenBalanceForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latestConsumeTimeForEnergy",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_LatestConsumeTimeForEnergy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, latestConsumeTimeForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "storageLimit",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_StorageLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, storageLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "storageUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_StorageUsage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, storageUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestExchangeStorageTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_LatestExchangeStorageTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, latestExchangeStorageTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account_AccountResource class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_AccountResource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TronAccount)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - authority

@implementation authority

@dynamic hasAccount, account;
@dynamic permissionName;

typedef struct authority__storage_ {
  uint32_t _has_storage_[1];
  AccountId *account;
  NSData *permissionName;
} authority__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountId),
        .number = authority_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(authority__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "permissionName",
        .dataTypeSpecific.className = NULL,
        .number = authority_FieldNumber_PermissionName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(authority__storage_, permissionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[authority class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(authority__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - permission

@implementation permission

@dynamic hasAccount, account;

typedef struct permission__storage_ {
  uint32_t _has_storage_[1];
  AccountId *account;
} permission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountId),
        .number = permission_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(permission__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[permission class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(permission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Witness

@implementation Witness

@dynamic address;
@dynamic voteCount;
@dynamic pubKey;
@dynamic URL;
@dynamic totalProduced;
@dynamic totalMissed;
@dynamic latestBlockNum;
@dynamic latestSlotNum;
@dynamic isJobs;

typedef struct Witness__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSData *pubKey;
  NSString *URL;
  int64_t voteCount;
  int64_t totalProduced;
  int64_t totalMissed;
  int64_t latestBlockNum;
  int64_t latestSlotNum;
} Witness__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Witness__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Witness__storage_, voteCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Witness__storage_, pubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Witness__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalProduced",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_TotalProduced,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Witness__storage_, totalProduced),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalMissed",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_TotalMissed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Witness__storage_, totalMissed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_LatestBlockNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Witness__storage_, latestBlockNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestSlotNum",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_LatestSlotNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Witness__storage_, latestSlotNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isJobs",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_IsJobs,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Witness class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Witness__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\002\t\000\003\006\000\004!!!\000\005\r\000\006\013\000\007\016\000\010\r\000\t\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Votes

@implementation Votes

@dynamic address;
@dynamic oldVotesArray, oldVotesArray_Count;
@dynamic newVotesArray, newVotesArray_Count;

typedef struct Votes__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *oldVotesArray;
  NSMutableArray *newVotesArray;
} Votes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Votes_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Votes__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "oldVotesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Votes_FieldNumber_OldVotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Votes__storage_, oldVotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newVotesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Votes_FieldNumber_NewVotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Votes__storage_, newVotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Votes class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Votes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXOutput

@implementation TXOutput

@dynamic value;
@dynamic pubKeyHash;

typedef struct TXOutput__storage_ {
  uint32_t _has_storage_[1];
  NSData *pubKeyHash;
  int64_t value;
} TXOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TXOutput_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXOutput__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKeyHash",
        .dataTypeSpecific.className = NULL,
        .number = TXOutput_FieldNumber_PubKeyHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXOutput__storage_, pubKeyHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXOutput class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXInput

@implementation TXInput

@dynamic hasRawData, rawData;
@dynamic signature;

typedef struct TXInput__storage_ {
  uint32_t _has_storage_[1];
  TXInput_raw *rawData;
  NSData *signature;
} TXInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(TXInput_raw),
        .number = TXInput_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXInput__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXInput__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXInput class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXInput_raw

@implementation TXInput_raw

@dynamic txId;
@dynamic vout;
@dynamic pubKey;

typedef struct TXInput_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *txId;
  NSData *pubKey;
  int64_t vout;
} TXInput_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_TxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, txId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "vout",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_Vout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, vout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, pubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXInput_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput_raw__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\003A\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TXInput)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXOutputs

@implementation TXOutputs

@dynamic outputsArray, outputsArray_Count;

typedef struct TXOutputs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *outputsArray;
} TXOutputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TXOutput),
        .number = TXOutputs_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TXOutputs__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXOutputs class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutputs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceReceipt

@implementation ResourceReceipt

@dynamic energyUsage;
@dynamic energyFee;
@dynamic originEnergyUsage;
@dynamic energyUsageTotal;
@dynamic netUsage;
@dynamic netFee;

typedef struct ResourceReceipt__storage_ {
  uint32_t _has_storage_[1];
  int64_t energyUsage;
  int64_t energyFee;
  int64_t originEnergyUsage;
  int64_t energyUsageTotal;
  int64_t netUsage;
  int64_t netFee;
} ResourceReceipt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "energyUsage",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_EnergyUsage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "energyFee",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_EnergyFee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "originEnergyUsage",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_OriginEnergyUsage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, originEnergyUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "energyUsageTotal",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_EnergyUsageTotal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyUsageTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "netUsage",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_NetUsage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, netUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "netFee",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_NetFee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, netFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResourceReceipt class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceReceipt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ResourceReceipt_code

GPBEnumDescriptor *ResourceReceipt_code_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Failed\000";
    static const int32_t values[] = {
        ResourceReceipt_code_Success,
        ResourceReceipt_code_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResourceReceipt_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResourceReceipt_code_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResourceReceipt_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResourceReceipt_code_Success:
    case ResourceReceipt_code_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction

@implementation TronTransaction

@dynamic hasRawData, rawData;
@dynamic signatureArray, signatureArray_Count;
@dynamic retArray, retArray_Count;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  Transaction_raw *rawData;
  NSMutableArray *signatureArray;
  NSMutableArray *retArray;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_raw),
        .number = Transaction_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatureArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_SignatureArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, signatureArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "retArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Result),
        .number = Transaction_FieldNumber_RetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, retArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TronTransaction class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Contract

@implementation Transaction_Contract

@dynamic type;
@dynamic hasParameter, parameter;
@dynamic provider;
@dynamic contractName;

typedef struct Transaction_Contract__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Contract_ContractType type;
  GPBAny *parameter;
  NSData *provider;
  NSData *contractName;
} Transaction_Contract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Transaction_Contract_ContractType_EnumDescriptor,
        .number = Transaction_Contract_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "parameter",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = Transaction_Contract_FieldNumber_Parameter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, parameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_Provider,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_ContractName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, contractName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Contract class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Contract__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TronTransaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_Contract_Type_RawValue(Transaction_Contract *message) {
  GPBDescriptor *descriptor = [Transaction_Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Contract_Type_RawValue(Transaction_Contract *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_Contract_ContractType

GPBEnumDescriptor *Transaction_Contract_ContractType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AccountCreateContract\000TransferContract\000T"
        "ransferAssetContract\000VoteAssetContract\000V"
        "oteWitnessContract\000WitnessCreateContract"
        "\000AssetIssueContract\000WitnessUpdateContrac"
        "t\000ParticipateAssetIssueContract\000AccountU"
        "pdateContract\000FreezeBalanceContract\000Unfr"
        "eezeBalanceContract\000WithdrawBalanceContr"
        "act\000UnfreezeAssetContract\000UpdateAssetCon"
        "tract\000ProposalCreateContract\000ProposalApp"
        "roveContract\000ProposalDeleteContract\000SetA"
        "ccountIdContract\000CustomContract\000CreateSm"
        "artContract\000TriggerSmartContract\000GetCont"
        "ract\000UpdateSettingContract\000ExchangeCreat"
        "eContract\000ExchangeInjectContract\000Exchang"
        "eWithdrawContract\000ExchangeTransactionCon"
        "tract\000";
    static const int32_t values[] = {
        Transaction_Contract_ContractType_AccountCreateContract,
        Transaction_Contract_ContractType_TransferContract,
        Transaction_Contract_ContractType_TransferAssetContract,
        Transaction_Contract_ContractType_VoteAssetContract,
        Transaction_Contract_ContractType_VoteWitnessContract,
        Transaction_Contract_ContractType_WitnessCreateContract,
        Transaction_Contract_ContractType_AssetIssueContract,
        Transaction_Contract_ContractType_WitnessUpdateContract,
        Transaction_Contract_ContractType_ParticipateAssetIssueContract,
        Transaction_Contract_ContractType_AccountUpdateContract,
        Transaction_Contract_ContractType_FreezeBalanceContract,
        Transaction_Contract_ContractType_UnfreezeBalanceContract,
        Transaction_Contract_ContractType_WithdrawBalanceContract,
        Transaction_Contract_ContractType_UnfreezeAssetContract,
        Transaction_Contract_ContractType_UpdateAssetContract,
        Transaction_Contract_ContractType_ProposalCreateContract,
        Transaction_Contract_ContractType_ProposalApproveContract,
        Transaction_Contract_ContractType_ProposalDeleteContract,
        Transaction_Contract_ContractType_SetAccountIdContract,
        Transaction_Contract_ContractType_CustomContract,
        Transaction_Contract_ContractType_CreateSmartContract,
        Transaction_Contract_ContractType_TriggerSmartContract,
        Transaction_Contract_ContractType_GetContract,
        Transaction_Contract_ContractType_UpdateSettingContract,
        Transaction_Contract_ContractType_ExchangeCreateContract,
        Transaction_Contract_ContractType_ExchangeInjectContract,
        Transaction_Contract_ContractType_ExchangeWithdrawContract,
        Transaction_Contract_ContractType_ExchangeTransactionContract,
    };
    static const char *extraTextFormatInfo = "\034\000\025\000\001\020\000\002\025\000\003\021\000\004\023\000\005\025\000\006\022\000\007\025\000\010\035\000\t\025\000\n\025\000\013\027\000\014\027\000\r\025\000\016\023\000\017\026\000\020\027\000\021\026\000\022\024\000\023\016\000\024\023\000\025\024\000\026\013\000\027\025\000\030\026\000\031\026\000\032\030\000\033\033\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Contract_ContractType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Contract_ContractType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Contract_ContractType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Contract_ContractType_AccountCreateContract:
    case Transaction_Contract_ContractType_TransferContract:
    case Transaction_Contract_ContractType_TransferAssetContract:
    case Transaction_Contract_ContractType_VoteAssetContract:
    case Transaction_Contract_ContractType_VoteWitnessContract:
    case Transaction_Contract_ContractType_WitnessCreateContract:
    case Transaction_Contract_ContractType_AssetIssueContract:
    case Transaction_Contract_ContractType_WitnessUpdateContract:
    case Transaction_Contract_ContractType_ParticipateAssetIssueContract:
    case Transaction_Contract_ContractType_AccountUpdateContract:
    case Transaction_Contract_ContractType_FreezeBalanceContract:
    case Transaction_Contract_ContractType_UnfreezeBalanceContract:
    case Transaction_Contract_ContractType_WithdrawBalanceContract:
    case Transaction_Contract_ContractType_UnfreezeAssetContract:
    case Transaction_Contract_ContractType_UpdateAssetContract:
    case Transaction_Contract_ContractType_ProposalCreateContract:
    case Transaction_Contract_ContractType_ProposalApproveContract:
    case Transaction_Contract_ContractType_ProposalDeleteContract:
    case Transaction_Contract_ContractType_SetAccountIdContract:
    case Transaction_Contract_ContractType_CustomContract:
    case Transaction_Contract_ContractType_CreateSmartContract:
    case Transaction_Contract_ContractType_TriggerSmartContract:
    case Transaction_Contract_ContractType_GetContract:
    case Transaction_Contract_ContractType_UpdateSettingContract:
    case Transaction_Contract_ContractType_ExchangeCreateContract:
    case Transaction_Contract_ContractType_ExchangeInjectContract:
    case Transaction_Contract_ContractType_ExchangeWithdrawContract:
    case Transaction_Contract_ContractType_ExchangeTransactionContract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_Result

@implementation Transaction_Result

@dynamic fee;
@dynamic ret;
@dynamic withdrawAmount;
@dynamic unfreezeAmount;

typedef struct Transaction_Result__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Result_code ret;
  int64_t fee;
  int64_t withdrawAmount;
  int64_t unfreezeAmount;
} Transaction_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_Fee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ret",
        .dataTypeSpecific.enumDescFunc = Transaction_Result_code_EnumDescriptor,
        .number = Transaction_Result_FieldNumber_Ret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "withdrawAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_WithdrawAmount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, withdrawAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unfreezeAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_UnfreezeAmount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, unfreezeAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Result class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Result__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TronTransaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_Result_Ret_RawValue(Transaction_Result *message) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Result_Ret_RawValue(Transaction_Result *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_Result_code

GPBEnumDescriptor *Transaction_Result_code_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Sucess\000Failed\000";
    static const int32_t values[] = {
        Transaction_Result_code_Sucess,
        Transaction_Result_code_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Result_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Result_code_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Result_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Result_code_Sucess:
    case Transaction_Result_code_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_raw

@implementation Transaction_raw

@dynamic refBlockBytes;
@dynamic refBlockNum;
@dynamic refBlockHash;
@dynamic expiration;
@dynamic authsArray, authsArray_Count;
@dynamic data_p;
@dynamic contractArray, contractArray_Count;
@dynamic scripts;
@dynamic timestamp;
@dynamic feeLimit;

typedef struct Transaction_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *refBlockBytes;
  NSData *refBlockHash;
  NSMutableArray *authsArray;
  NSData *data_p;
  NSMutableArray *contractArray;
  NSData *scripts;
  int64_t refBlockNum;
  int64_t expiration;
  int64_t timestamp;
  int64_t feeLimit;
} Transaction_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "refBlockBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "refBlockHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, expiration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "authsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(authority),
        .number = Transaction_raw_FieldNumber_AuthsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, authsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Contract),
        .number = Transaction_raw_FieldNumber_ContractArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, contractArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scripts",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Scripts,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, scripts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_FeeLimit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_raw__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TronTransaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionInfo

@implementation TransactionInfo

@dynamic id_p;
@dynamic fee;
@dynamic blockNumber;
@dynamic blockTimeStamp;
@dynamic contractResultArray, contractResultArray_Count;
@dynamic contractAddress;
@dynamic hasReceipt, receipt;
@dynamic logArray, logArray_Count;
@dynamic result;
@dynamic resMessage;
@dynamic withdrawAmount;
@dynamic unfreezeAmount;

typedef struct TransactionInfo__storage_ {
  uint32_t _has_storage_[1];
  TransactionInfo_code result;
  NSData *id_p;
  NSMutableArray *contractResultArray;
  NSData *contractAddress;
  ResourceReceipt *receipt;
  NSMutableArray *logArray;
  NSData *resMessage;
  int64_t fee;
  int64_t blockNumber;
  int64_t blockTimeStamp;
  int64_t withdrawAmount;
  int64_t unfreezeAmount;
} TransactionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_BlockNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, blockNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockTimeStamp",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_BlockTimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, blockTimeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "contractResultArray",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ContractResultArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, contractResultArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractAddress",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ContractAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, contractAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = GPBStringifySymbol(ResourceReceipt),
        .number = TransactionInfo_FieldNumber_Receipt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionInfo_Log),
        .number = TransactionInfo_FieldNumber_LogArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, logArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = TransactionInfo_code_EnumDescriptor,
        .number = TransactionInfo_FieldNumber_Result,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "resMessage",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ResMessage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, resMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "withdrawAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_WithdrawAmount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, withdrawAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unfreezeAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_UnfreezeAmount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, unfreezeAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\003\013\000\004\016\000\005\000contractResult\000\n\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TransactionInfo_Result_RawValue(TransactionInfo *message) {
  GPBDescriptor *descriptor = [TransactionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionInfo_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransactionInfo_Result_RawValue(TransactionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [TransactionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionInfo_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum TransactionInfo_code

GPBEnumDescriptor *TransactionInfo_code_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Sucess\000Failed\000";
    static const int32_t values[] = {
        TransactionInfo_code_Sucess,
        TransactionInfo_code_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionInfo_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionInfo_code_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransactionInfo_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransactionInfo_code_Sucess:
    case TransactionInfo_code_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TransactionInfo_Log

@implementation TransactionInfo_Log

@dynamic address;
@dynamic topicsArray, topicsArray_Count;
@dynamic data_p;

typedef struct TransactionInfo_Log__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *topicsArray;
  NSData *data_p;
} TransactionInfo_Log__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_Log_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "topicsArray",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_Log_FieldNumber_TopicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, topicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_Log_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionInfo_Log class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfo_Log__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TransactionInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transactions

@implementation Transactions

@dynamic transactionsArray, transactionsArray_Count;

typedef struct Transactions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} Transactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TronTransaction),
        .number = Transactions_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transactions__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transactions class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transactions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionSign

@implementation TransactionSign

@dynamic hasTransaction, transaction;
@dynamic privateKey;

typedef struct TransactionSign__storage_ {
  uint32_t _has_storage_[1];
  TronTransaction *transaction;
  NSData *privateKey;
} TransactionSign__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(TronTransaction),
        .number = TransactionSign_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionSign__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "privateKey",
        .dataTypeSpecific.className = NULL,
        .number = TransactionSign_FieldNumber_PrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionSign__storage_, privateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionSign class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionSign__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader

@implementation BlockHeader

@dynamic hasRawData, rawData;
@dynamic witnessSignature;

typedef struct BlockHeader__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader_raw *rawData;
  NSData *witnessSignature;
} BlockHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader_raw),
        .number = BlockHeader_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witnessSignature",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_WitnessSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, witnessSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader_raw

@implementation BlockHeader_raw

@dynamic timestamp;
@dynamic txTrieRoot;
@dynamic parentHash;
@dynamic number;
@dynamic witnessId;
@dynamic witnessAddress;

typedef struct BlockHeader_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *txTrieRoot;
  NSData *parentHash;
  NSData *witnessAddress;
  int64_t timestamp;
  int64_t number;
  int64_t witnessId;
} BlockHeader_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txTrieRoot",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_TxTrieRoot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, txTrieRoot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parentHash",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_ParentHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, parentHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Number,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "witnessId",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_WitnessId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "witnessAddress",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_WitnessAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader_raw__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\n\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BlockHeader)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic transactionsArray, transactionsArray_Count;
@dynamic hasBlockHeader, blockHeader;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
  BlockHeader *blockHeader;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TronTransaction),
        .number = Block_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeader",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Block_FieldNumber_BlockHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, blockHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainInventory

@implementation ChainInventory

@dynamic idsArray, idsArray_Count;
@dynamic remainNum;

typedef struct ChainInventory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
  int64_t remainNum;
} ChainInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainInventory_BlockId),
        .number = ChainInventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainInventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remainNum",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_FieldNumber_RemainNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainInventory__storage_, remainNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainInventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainInventory_BlockId

@implementation ChainInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct ChainInventory_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} ChainInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainInventory_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory_BlockId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChainInventory)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockInventory

@implementation BlockInventory

@dynamic idsArray, idsArray_Count;
@dynamic type;

typedef struct BlockInventory__storage_ {
  uint32_t _has_storage_[1];
  BlockInventory_Type type;
  NSMutableArray *idsArray;
} BlockInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockInventory_BlockId),
        .number = BlockInventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockInventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BlockInventory_Type_EnumDescriptor,
        .number = BlockInventory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInventory__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BlockInventory_Type_RawValue(BlockInventory *message) {
  GPBDescriptor *descriptor = [BlockInventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBlockInventory_Type_RawValue(BlockInventory *message, int32_t value) {
  GPBDescriptor *descriptor = [BlockInventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum BlockInventory_Type

GPBEnumDescriptor *BlockInventory_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Sync\000Advtise\000Fetch\000";
    static const int32_t values[] = {
        BlockInventory_Type_Sync,
        BlockInventory_Type_Advtise,
        BlockInventory_Type_Fetch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BlockInventory_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BlockInventory_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BlockInventory_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BlockInventory_Type_Sync:
    case BlockInventory_Type_Advtise:
    case BlockInventory_Type_Fetch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockInventory_BlockId

@implementation BlockInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct BlockInventory_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} BlockInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = BlockInventory_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockInventory_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInventory_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory_BlockId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BlockInventory)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Inventory

@implementation Inventory

@dynamic type;
@dynamic idsArray, idsArray_Count;

typedef struct Inventory__storage_ {
  uint32_t _has_storage_[1];
  Inventory_InventoryType type;
  NSMutableArray *idsArray;
} Inventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Inventory_InventoryType_EnumDescriptor,
        .number = Inventory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Inventory__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = Inventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Inventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Inventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Inventory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Inventory_Type_RawValue(Inventory *message) {
  GPBDescriptor *descriptor = [Inventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventory_Type_RawValue(Inventory *message, int32_t value) {
  GPBDescriptor *descriptor = [Inventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Inventory_InventoryType

GPBEnumDescriptor *Inventory_InventoryType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Trx\000Block\000";
    static const int32_t values[] = {
        Inventory_InventoryType_Trx,
        Inventory_InventoryType_Block,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Inventory_InventoryType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Inventory_InventoryType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Inventory_InventoryType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Inventory_InventoryType_Trx:
    case Inventory_InventoryType_Block:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Items

@implementation Items

@dynamic type;
@dynamic blocksArray, blocksArray_Count;
@dynamic blockHeadersArray, blockHeadersArray_Count;
@dynamic transactionsArray, transactionsArray_Count;

typedef struct Items__storage_ {
  uint32_t _has_storage_[1];
  Items_ItemType type;
  NSMutableArray *blocksArray;
  NSMutableArray *blockHeadersArray;
  NSMutableArray *transactionsArray;
} Items__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Items_ItemType_EnumDescriptor,
        .number = Items_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Items__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = Items_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeadersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Items_FieldNumber_BlockHeadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, blockHeadersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TronTransaction),
        .number = Items_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Items class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Items__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Items_Type_RawValue(Items *message) {
  GPBDescriptor *descriptor = [Items descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetItems_Type_RawValue(Items *message, int32_t value) {
  GPBDescriptor *descriptor = [Items descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Items_ItemType

GPBEnumDescriptor *Items_ItemType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Err\000Trx\000Block\000Blockheader\000";
    static const int32_t values[] = {
        Items_ItemType_Err,
        Items_ItemType_Trx,
        Items_ItemType_Block,
        Items_ItemType_Blockheader,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Items_ItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Items_ItemType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Items_ItemType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Items_ItemType_Err:
    case Items_ItemType_Trx:
    case Items_ItemType_Block:
    case Items_ItemType_Blockheader:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DynamicProperties

@implementation DynamicProperties

@dynamic lastSolidityBlockNum;

typedef struct DynamicProperties__storage_ {
  uint32_t _has_storage_[1];
  int64_t lastSolidityBlockNum;
} DynamicProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastSolidityBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = DynamicProperties_FieldNumber_LastSolidityBlockNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DynamicProperties__storage_, lastSolidityBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DynamicProperties class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DynamicProperties__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectMessage

@implementation DisconnectMessage

@dynamic reason;

typedef struct DisconnectMessage__storage_ {
  uint32_t _has_storage_[1];
  ReasonCode reason;
} DisconnectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = ReasonCode_EnumDescriptor,
        .number = DisconnectMessage_FieldNumber_Reason,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectMessage__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectMessage class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DisconnectMessage_Reason_RawValue(DisconnectMessage *message) {
  GPBDescriptor *descriptor = [DisconnectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
  return GPBGetMessageInt32Field(message, field);
}

void SetDisconnectMessage_Reason_RawValue(DisconnectMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [DisconnectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - HelloMessage

@implementation HelloMessage

@dynamic hasFrom, from;
@dynamic version;
@dynamic timestamp;
@dynamic hasGenesisBlockId, genesisBlockId;
@dynamic hasSolidBlockId, solidBlockId;
@dynamic hasHeadBlockId, headBlockId;

typedef struct HelloMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  Endpoint *from;
  HelloMessage_BlockId *genesisBlockId;
  HelloMessage_BlockId *solidBlockId;
  HelloMessage_BlockId *headBlockId;
  int64_t timestamp;
} HelloMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = GPBStringifySymbol(Endpoint),
        .number = HelloMessage_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "genesisBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_GenesisBlockId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, genesisBlockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "solidBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_SolidBlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, solidBlockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "headBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_HeadBlockId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, headBlockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloMessage class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\016\000\005\014\000\006\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HelloMessage_BlockId

@implementation HelloMessage_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct HelloMessage_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} HelloMessage_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloMessage_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage_BlockId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(HelloMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StorageItem

@implementation StorageItem

@dynamic contractAddress;
@dynamic items, items_Count;

typedef struct StorageItem__storage_ {
  uint32_t _has_storage_[1];
  NSData *contractAddress;
  NSMutableDictionary *items;
} StorageItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contractAddress",
        .dataTypeSpecific.className = NULL,
        .number = StorageItem_FieldNumber_ContractAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StorageItem__storage_, contractAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "items",
        .dataTypeSpecific.className = NULL,
        .number = StorageItem_FieldNumber_Items,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StorageItem__storage_, items),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StorageItem class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StorageItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StorageRow

@implementation StorageRow

@dynamic key;
@dynamic value;

typedef struct StorageRow__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  NSData *value;
} StorageRow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = StorageRow_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StorageRow__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = StorageRow_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StorageRow__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StorageRow class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StorageRow__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SmartContract

@implementation SmartContract

@dynamic originAddress;
@dynamic contractAddress;
@dynamic hasAbi, abi;
@dynamic bytecode;
@dynamic callValue;
@dynamic consumeUserResourcePercent;
@dynamic name;

typedef struct SmartContract__storage_ {
  uint32_t _has_storage_[1];
  NSData *originAddress;
  NSData *contractAddress;
  SmartContract_ABI *abi;
  NSData *bytecode;
  NSString *name;
  int64_t callValue;
  int64_t consumeUserResourcePercent;
} SmartContract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "originAddress",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_FieldNumber_OriginAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SmartContract__storage_, originAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractAddress",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_FieldNumber_ContractAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SmartContract__storage_, contractAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "abi",
        .dataTypeSpecific.className = GPBStringifySymbol(SmartContract_ABI),
        .number = SmartContract_FieldNumber_Abi,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SmartContract__storage_, abi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bytecode",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_FieldNumber_Bytecode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SmartContract__storage_, bytecode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "callValue",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_FieldNumber_CallValue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SmartContract__storage_, callValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "consumeUserResourcePercent",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_FieldNumber_ConsumeUserResourcePercent,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SmartContract__storage_, consumeUserResourcePercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_FieldNumber_Name,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SmartContract__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SmartContract class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SmartContract__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SmartContract_ABI

@implementation SmartContract_ABI

@dynamic entrysArray, entrysArray_Count;

typedef struct SmartContract_ABI__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entrysArray;
} SmartContract_ABI__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entrysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SmartContract_ABI_Entry),
        .number = SmartContract_ABI_FieldNumber_EntrysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SmartContract_ABI__storage_, entrysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SmartContract_ABI class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SmartContract_ABI__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SmartContract)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SmartContract_ABI_Entry

@implementation SmartContract_ABI_Entry

@dynamic anonymous;
@dynamic constant;
@dynamic name;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic type;
@dynamic payable;
@dynamic stateMutability;

typedef struct SmartContract_ABI_Entry__storage_ {
  uint32_t _has_storage_[1];
  SmartContract_ABI_Entry_EntryType type;
  SmartContract_ABI_Entry_StateMutabilityType stateMutability;
  NSString *name;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
} SmartContract_ABI_Entry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "anonymous",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_FieldNumber_Anonymous,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "constant",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_FieldNumber_Constant,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_FieldNumber_Name,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SmartContract_ABI_Entry_Param),
        .number = SmartContract_ABI_Entry_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SmartContract_ABI_Entry_Param),
        .number = SmartContract_ABI_Entry_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SmartContract_ABI_Entry_EntryType_EnumDescriptor,
        .number = SmartContract_ABI_Entry_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "payable",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_FieldNumber_Payable,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stateMutability",
        .dataTypeSpecific.enumDescFunc = SmartContract_ABI_Entry_StateMutabilityType_EnumDescriptor,
        .number = SmartContract_ABI_Entry_FieldNumber_StateMutability,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry__storage_, stateMutability),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SmartContract_ABI_Entry class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SmartContract_ABI_Entry__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SmartContract_ABI)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SmartContract_ABI_Entry_Type_RawValue(SmartContract_ABI_Entry *message) {
  GPBDescriptor *descriptor = [SmartContract_ABI_Entry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SmartContract_ABI_Entry_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetSmartContract_ABI_Entry_Type_RawValue(SmartContract_ABI_Entry *message, int32_t value) {
  GPBDescriptor *descriptor = [SmartContract_ABI_Entry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SmartContract_ABI_Entry_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SmartContract_ABI_Entry_StateMutability_RawValue(SmartContract_ABI_Entry *message) {
  GPBDescriptor *descriptor = [SmartContract_ABI_Entry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SmartContract_ABI_Entry_FieldNumber_StateMutability];
  return GPBGetMessageInt32Field(message, field);
}

void SetSmartContract_ABI_Entry_StateMutability_RawValue(SmartContract_ABI_Entry *message, int32_t value) {
  GPBDescriptor *descriptor = [SmartContract_ABI_Entry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SmartContract_ABI_Entry_FieldNumber_StateMutability];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SmartContract_ABI_Entry_EntryType

GPBEnumDescriptor *SmartContract_ABI_Entry_EntryType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownEntryType\000Constructor\000Function\000Ev"
        "ent\000Fallback\000";
    static const int32_t values[] = {
        SmartContract_ABI_Entry_EntryType_UnknownEntryType,
        SmartContract_ABI_Entry_EntryType_Constructor,
        SmartContract_ABI_Entry_EntryType_Function,
        SmartContract_ABI_Entry_EntryType_Event,
        SmartContract_ABI_Entry_EntryType_Fallback,
    };
    static const char *extraTextFormatInfo = "\005\000\020\000\001\013\000\002\010\000\003\005\000\004\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SmartContract_ABI_Entry_EntryType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SmartContract_ABI_Entry_EntryType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SmartContract_ABI_Entry_EntryType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SmartContract_ABI_Entry_EntryType_UnknownEntryType:
    case SmartContract_ABI_Entry_EntryType_Constructor:
    case SmartContract_ABI_Entry_EntryType_Function:
    case SmartContract_ABI_Entry_EntryType_Event:
    case SmartContract_ABI_Entry_EntryType_Fallback:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SmartContract_ABI_Entry_StateMutabilityType

GPBEnumDescriptor *SmartContract_ABI_Entry_StateMutabilityType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownMutabilityType\000Pure\000View\000Nonpayab"
        "le\000Payable\000";
    static const int32_t values[] = {
        SmartContract_ABI_Entry_StateMutabilityType_UnknownMutabilityType,
        SmartContract_ABI_Entry_StateMutabilityType_Pure,
        SmartContract_ABI_Entry_StateMutabilityType_View,
        SmartContract_ABI_Entry_StateMutabilityType_Nonpayable,
        SmartContract_ABI_Entry_StateMutabilityType_Payable,
    };
    static const char *extraTextFormatInfo = "\005\000\025\000\001\004\000\002\004\000\003\n\000\004\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SmartContract_ABI_Entry_StateMutabilityType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SmartContract_ABI_Entry_StateMutabilityType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SmartContract_ABI_Entry_StateMutabilityType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SmartContract_ABI_Entry_StateMutabilityType_UnknownMutabilityType:
    case SmartContract_ABI_Entry_StateMutabilityType_Pure:
    case SmartContract_ABI_Entry_StateMutabilityType_View:
    case SmartContract_ABI_Entry_StateMutabilityType_Nonpayable:
    case SmartContract_ABI_Entry_StateMutabilityType_Payable:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SmartContract_ABI_Entry_Param

@implementation SmartContract_ABI_Entry_Param

@dynamic indexed;
@dynamic name;
@dynamic type;

typedef struct SmartContract_ABI_Entry_Param__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *type;
} SmartContract_ABI_Entry_Param__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "indexed",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_Param_FieldNumber_Indexed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_Param_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry_Param__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = SmartContract_ABI_Entry_Param_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SmartContract_ABI_Entry_Param__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SmartContract_ABI_Entry_Param class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SmartContract_ABI_Entry_Param__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SmartContract_ABI_Entry)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
